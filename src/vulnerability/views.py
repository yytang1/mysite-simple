from django.shortcuts import render_to_response
from django.http import HttpResponse
from vulnerability.models import CVE, REUSE, CVSS, EXPLOIT, INFO, FEATURE, REUSEFEATURE, DIFFFEATURE
# from vulnerability.models import RegisterForm
from django.db import connection
import re
from django.db.models import Q
PAGENUMS = 20
DIFFFILENAME = 'difffile/'

class PageIndex:
    def __init__(self):
        self.sum = 0
        self.curIndex = 0
        self.endIndex = 0
        self.lastPageIndex = 0
        self.firstPageNum = 1
        self.curPageNum = 1
        self.endPageNum = 1
        self.pages = range(self.curPageNum, self.curPageNum + 10)
        self.page = 1  # only for pages
        self.queryString = None
    def getPageIndex(self):  # from pages Num to Index
        index = (self.page - 1) * PAGENUMS
        self.page += 1
        return index
    def getEndIndex(self):
        endIndex = int(self.curIndex) + PAGENUMS - 1
        if endIndex > self.sum:
            return self.sum
        else:
            return endIndex
class VulnerabilityDetail:
    def __init__(self):
        self.CVE = CVE
        self.CVSS = CVSS
        self.INFO = []
        self.EXPLOITS = []
        self.REUSES = []
        self.FUNC = []
def getVulnerabilityDetail(cveid, req):   
    errors = [] 
    vulnerabilityDetail = VulnerabilityDetail()
    try:
        cve = CVE.objects.get(cve_id=cveid)
        print(cve)
        vulnerabilityDetail.CVE = cve
        vulnerabilityDetail.CVSS = CVSS.objects.filter(cveid=cve)
        vulnerabilityDetail.EXPLOITS = EXPLOIT.objects.filter(cve=cve)
        vulnerabilityDetail.INFO = INFO.objects.filter(cve=cve)
        for info in vulnerabilityDetail.INFO:
            info.feature = DIFFFEATURE.objects.filter(info_id=info)
            reuses = REUSE.objects.filter(info_id=info)
            for reuse in reuses:
                reuse.feature = REUSEFEATURE.objects.filter(reuse=reuse)
                vulnerabilityDetail.REUSES.append(reuse)
        return vulnerabilityDetail
    except Exception as err:
        errors.append(err) 
        print(errors) 
        return None
# Create your views here.

def index(req):
    return render_to_response('index.html' , {'user':req.user})

def vulnerabilityNVD(req):
    errors = []
    try:
        sum1 = CVE.objects.count()
        pageInfo = pagination_vul(int(sum1), req)
        vulnerabilities = CVE.objects.order_by('-cve_id').all()[pageInfo.curIndex - 1:pageInfo.endIndex]
        if pageInfo.curIndex == 1:
            pageInfo.curIndex = 0
        for vuln in vulnerabilities:
            vuln.exploits = vuln.exploit_set.count()
        return render_to_response('vulnerabilityNVD.html', {\
                                                    'vulnerabilities':vulnerabilities, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo})
    except Exception as err:
        errors.append(err)  
        return render_to_response('vulnerabilityNVD.html', {'errors': errors, 'pageInfo':pageInfo})
def vulnerabilityPatch(req):
    errors = []
    header = 'Vulnerabilities With Patch List:'
    try:
    # vulnerabilities with patch
        sum1 = INFO.objects.exclude(Q(diff_link='') | Q(diff_file='')).values('cve').distinct().count()
        pageInfo = pagination_vul(int(sum1), req)
        cves = INFO.objects.exclude(Q(diff_link='') | Q(diff_file='')).values('cve').distinct().order_by('-cve')[pageInfo.curIndex - 1:pageInfo.endIndex]
        if pageInfo.curIndex == 1:
            pageInfo.curIndex = 0
        vulnerabilitiesWithPatch = []
        for cve in cves:
            vuln = CVE.objects.get(cve_id=cve['cve'])
            vuln.exploits = vuln.exploit_set.count()
            vulnerabilitiesWithPatch.append(vuln)
        return render_to_response('vulnerabilityWithPatch.html', {\
                                                    'vulnerabilities':vulnerabilitiesWithPatch, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo, 'header':header})
    except Exception as err:
        errors.append(err)
        return render_to_response('vulnerabilityWithPatch.html', {'errors': errors, 'header':header})

def vulnerabilityReuse(req):    
    errors = []
    try:
        reuses = REUSE.objects.all()
        vulnerabilitiesWithReuse = []
        for reuse in reuses:
            if reuse.info_id.cve not in vulnerabilitiesWithReuse:
                vulnerabilitiesWithReuse.append(reuse.info_id.cve)
        sumReuse = len(vulnerabilitiesWithReuse)
        pageInfo = pagination_vul(int(sumReuse), req) 
        for vuln in vulnerabilitiesWithReuse:
            vuln.exploits = vuln.exploit_set.count()
        return render_to_response('vulnerabilityWithReuse.html', {\
                                                    'vulnerabilities':vulnerabilitiesWithReuse, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo})
    except Exception as err:
        errors.append(err)  
        return render_to_response('vulnerabilityWithReuse.html', {'errors': errors, 'pageInfo':pageInfo})
    
def detailVul(req):
    errors = []
    try:
        if 'q' in req.GET:
            q = req.GET['q']
            if not validCVE(q):
                errors.append('Enter a search term.')
            else:
                if not re.match('^CVE-', q):
                    q = 'CVE-' + q
            vulnerabilityDetail = getVulnerabilityDetail(q, req)
            if vulnerabilityDetail == None:
                errors.append("No Term Found")
                return render_to_response('detail_vul.html', {'errors': errors, 'query':q})
            return render_to_response('detail_vul.html', {'query':q, 'vulnerabilityDetail':vulnerabilityDetail})
        return render_to_response('detail_vul.html', {'errors': errors})
    except Exception as err:
        errors.append(err)
        return render_to_response('detail_vul.html', {'errors': errors})
    

def validCVE(cveid):
    patt = '^(CVE-)?[0-9]{4}-[0-9]{1,39}$'
    m = re.match(patt, cveid)
    if not m:
        return False
    return True

def searchCVE(req):
    errors = []
    query = []
    q = req.GET['q']
    if not q:
        errors.append('Enter a search term.')
    elif not validCVE(q):
        errors.append('Incorrect CVE ID, expected format: CVE-[0-9]{4}-[0-9]{1,39} or [0-9]{4}-[0-9]{1,39}')
    else:            
        query.append(q)
        try:
            vulnerabilities = CVE.objects.filter(cve_id__contains=q)
            for vuln in vulnerabilities:
                vuln.exploits = vuln.exploit_set.count()
            pageInfo = pagination_vul(len(vulnerabilities), req)
            return render_to_response('search_results.html', {'vulnerabilities':vulnerabilities, 'user':req.user, 'q':q, 'pageInfo':pageInfo})
        except:
            errors.append("ERROR")
    return render_to_response('search_results.html', {'errors': errors, 'q':q, 'user':req.user})      

def searchVul(req):
    if 'q' in req.GET:  # search 
        return searchCVE(req)
    elif 'ad_q' in req.GET:  # advanced search
        return searchAdvanced(req)
    # elif 'Analysis' in req.GET:  # analysis
    #    return analysis(req)
    else:
        return render_to_response('404.html') 

def searchAdvanced(req):
        errors = []
        query = []
        vulnerabilities = []
        cursor = connection.cursor()
        sql = "select * from vulnerability_cve"
        condition = None
        exploitsFlag = 0
        if 'ExploitsCheckBox' in req.GET:
            ExploitsCheck = req.GET['ExploitsCheckBox']
            if ExploitsCheck:
                exploitsFlag = 1
                
        reuseFlag = 0
        if 'ReuseCheckBox' in req.GET:
            ReuseCheck = req.GET['ReuseCheckBox']
            if ReuseCheck:
                reuseFlag = 1
                
        resuseFeatureFlag = 0
        resuseFeatureCves = []
        if 'ReuseFeatureList' in req.GET:
            ReuseFeature = req.GET['ReuseFeatureList']
            if ReuseFeature:
                resuseFeatureFlag = 1
                feature = FEATURE.objects.get(id=ReuseFeature)
                resuseFeatures = REUSEFEATURE.objects.filter(feature=feature)
                for reuseFeature in resuseFeatures:
                    if reuseFeature.reuse.info_id.cve not in resuseFeatureCves:
                        resuseFeatureCves.append(reuseFeature.reuse.info_id.cve)
        diffFlag = 0        
        if 'DiffCheckBox' in req.GET:
            DiffCheck = req.GET['DiffCheckBox']
            if DiffCheck:
                diffFlag = 1
        # CveIdentifier CveIdentifierTextBox
        CveIdentifier = req.GET['CveIdentifierTextBox']
        if CveIdentifier:
            if not validCVE(CveIdentifier):
                errors.append('Incorrect CVE ID, expected format: CVE-[0-9]{4}-[0-9]{1,39} or [0-9]{4}-[0-9]{1,39}')
            else:
                temp = "CVEID rlike '[CVE-]?" + CveIdentifier + "'" 
                condition = add_condition(condition, temp)
                query.append('CVEID:' + CveIdentifier)
        
        # Keyword QueryTextBox    
        keyword = req.GET['QueryTextBox']
        if keyword:
            if len(keyword) > 20:
                errors.append('Please submit keyword 20 characters or shorter')
            else:
                temp = "Description rlike '.*" + keyword + ".*'" 
                condition = add_condition(condition, temp)
                query.append('Description KeyWords:' + keyword)
                
        # cweid CweDropDownList    
        cweid = req.GET['CweDropDownList']
        if cweid != "":
            if (cweid == "CWE-noinfo") or (cweid == 'CWE-Other'):
                temp = "cweid is null"
            else:
                temp = "CWEID = '" + cweid + "'"
                query.append('CWEID:' + "Get the CWE Value from ID is not done .we have no cwe dictionary yet")
            condition = add_condition(condition, temp)
            
        # Vendor CPEVendorTextBox
        vendor = req.GET['CPEVendorTextBox']
        if vendor:
            if len(vendor) > 20:
                errors.append('Please submit Vendor 20 characters or shorter')
            else:  # if has cpe then use cpe sql
                sql = "select * from vulnerability_cve"
                temp = "company= '" + vendor + "'"
                condition = add_condition(condition, temp)
                query.append('Vendor:' + vendor)
        # Product CPEProductTextBox
        product = req.GET['CPEProductTextBox']
        if product:
            if len(product) > 20:
                errors.append('Please submit Product 20 characters or shorter')
            else:  # if has cpe then use cpe sql
                sql = "select * from vulnerability_cve"
                temp = "name rlike '.*" + product + ".*'"
                condition = add_condition(condition, temp)
                query.append('Product:' + product)
        # version CPEVersionTextBox
        version = req.GET['CPEVersionTextBox']
        if version:
            if not product:
                errors.append('Version needs Product first')
            elif len(version) > 20:
                errors.append('Please submit Version 20 characters or shorter')
            else:
                sql = "select * from vulnerability_cve"
                temp = "SoftwareVersion = '" + version + "'"
                condition = add_condition(condition, temp)
                query.append('Version:' + version)
        # Modify date Range
        # startTime ModDateStartMonthDropDown ModDateStartYearDropDown
        flag = None
        month = req.GET['ModDateStartMonthDropDown']
        year = req.GET['ModDateStartYearDropDown']
        if month != "0" and year != "0":
            startTime = year + "-" + month.zfill(2) + "-01T00:00.000-00:00"
            temp = "update_date >= '" + startTime + "'"
            condition = add_condition(condition, temp)
            query.append('Modified Date Start Time:' + year + "-" + month.zfill(2))
        elif (month == '0' and year != '0') or (month != '0' and year == '0'):
            flag = 1
        # endTime  ModDateEndMonthDropDown ModDateEndYearDropDown
        month = req.GET['ModDateEndMonthDropDown']
        year = req.GET['ModDateEndYearDropDown']
        if month != "0" and year != "0":
            endTime = year + "-" + month.zfill(2) + "-31T23:59.999-23:59"
            temp = "update_date <= '" + endTime + "'"
            condition = add_condition(condition, temp)
            query.append('Modified Date End Time:' + year + "-" + month.zfill(2))
        elif (month == '0' and year != '0') or (month != '0' and year == '0'):
            flag = 1 
        if flag != None:
            errors.append('Any dates chosen must select both Month and Year')
        # CVSS 
        # CvssSevBaseDropDown
        res = req.GET['CvssSevBaseDropDown']
        if res != "":
            if res == "LOW":
                low = 0
                high = 3
            elif res == "MEDIUM":
                low = 4
                high = 6
            elif res == "MEDIUM_HIGH":
                low = 4
                high = 10
            elif res == "HIGH":
                low = 7
                high = 10
            temp = "CVSS >= '%s' and CVSS <= '%s'" % (low, high)
            condition = add_condition(condition, temp)
            query.append('Severity (Base Score Range):' + str(res))
            # CvssAvDropDown
        
        res = req.GET['CvssAvDropDown']
        cvssAv = 0
        cvsss = []
        cvss_cves = []
        if res != "":
            cvssAv = 1
            if res == "LOCAL":
                cvsss = CVSS.objects.exclude(accessVector__icontains='network').filter(accessVector__icontains='Local')
            elif res == "LOCAL_NETWORK":
                cvsss = CVSS.objects.filter(accessVector__icontains='network').filter(accessVector__icontains='Local')
            elif res == "NETWORK":
                cvsss = CVSS.objects.exclude(accessVector__icontains='Local').filter(accessVector__icontains='network')
            for cvss in cvsss:
                if cvss.cveid not in cvss_cves:
                    cvss_cves.append(cvss.cveid)
        if errors:
            return render_to_response('search_advanced.html', {'errors': errors})
        if condition:
            sql = sql + " where " + condition + " order by CVEID DESC"
        try:
            sql += ";"
            print(sql)
            cursor.execute(sql)
            # get data
            desc = cursor.description
            rows = [ dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]
            
            rows = rows
            print(rows)
            for row in rows:
                cveid = row['CVEID']
                vulnTemp = CVE.objects.get(cve_id=cveid)   
                vulnTemp.exploits = vulnTemp.exploit_set.count()
                if exploitsFlag > 0 and vulnTemp.exploits <= 0:
                    continue
                if reuseFlag > 0:
                    info = INFO.objects.filter(cve=vulnTemp)
                    if not info:
                        continue
                    reuse = REUSE.objects.filter(info_id=info[0])
                    if not reuse:
                        continue
                if diffFlag > 0:
                    info = INFO.objects.filter(cve=vulnTemp).exclude(diff_link='')
                    if not info:
                        continue
                if cvssAv > 0:
                    if vulnTemp not in cvss_cves:
                        continue
                if resuseFeatureFlag > 0:
                    if vulnTemp not in resuseFeatureCves:
                        continue
                vulnerabilities.append(vulnTemp)
            return render_to_response('search_results.html',
                {'vulnerabilities':vulnerabilities, 'q':query})
        except:
            errors.append('Execute sql error')
        finally:
            cursor.close()
        return render_to_response('searchAdvanced.html', {'errors': errors})
def add_condition(condition, str1):
    if condition:
        str1 = " and " + str1 
        condition += str1
    else:
        condition = str1
    return condition
def search_advanced(req):
    # show query page 
    features = FEATURE.objects.all()
    return render_to_response('searchAdvanced.html', {'features':features})

def pagination_vul(sum1, request):
    errors = []
    pageInfo = PageIndex()
    try:
        # page index info
        pageInfo.sum = sum1
        if sum1 % PAGENUMS == 0:
            pageInfo.endPageNum = int(sum1 / PAGENUMS)
        else:
            pageInfo.endPageNum = int(sum1 / PAGENUMS) + 1
        # query string  
        if 'QUERY_STRING' in request.META:
            queryString = request.META['QUERY_STRING']
            re.sub('&startIndex.*$', '', queryString)
            pageInfo.queryString = queryString
        startIndex = 0
        if 'startIndex' in request.GET:
            startIndex = int(request.GET['startIndex'])
          ###########take care of request
        pageInfo.curIndex = startIndex + 1  # page index start from 1,so it needs +1 there  
        pageInfo.endIndex = pageInfo.getEndIndex()
        if sum1 > PAGENUMS:
            pageInfo.lastPageIndex = sum1 - sum1 % PAGENUMS
        else:
            pageInfo.lastPageIndex = 0
        # page num info
        firstPageNum = 1
        if 'firstPageNum' in request.GET:
            firstPageNum = int(request.GET['firstPageNum'])
        # if request.session.get('firstpagenum'):
            # firstPageNum = request.session['firstpagenum']
        # else:
            # request.session['firstpagenum'] = firstPageNum
        lastPageNum = firstPageNum + 9
        if lastPageNum > pageInfo.endPageNum:
            lastPageNum = pageInfo.endPageNum
        pageInfo.curPageNum = int(startIndex / PAGENUMS) + 1
        pageInfo.pages = range(firstPageNum, lastPageNum + 1)
        if pageInfo.curPageNum == lastPageNum:  # and pageInfo.curPageNum != pageInfo.endPageNum:#the last pageNum adjust nav bar
            lastPageNum = pageInfo.curPageNum + 5 
            if lastPageNum > pageInfo.endPageNum:
                lastPageNum = pageInfo.endPageNum
            firstPageNum = lastPageNum - 9
            if firstPageNum < 1:
                firstPageNum = 1
        elif pageInfo.curPageNum == firstPageNum and pageInfo.curPageNum != 1:  # and pageInfo.curPageNum != 1:
            firstPageNum = pageInfo.curPageNum - 5
            if firstPageNum < 1:
                firstPageNum = 1
            lastPageNum = firstPageNum + 9
        elif pageInfo.curPageNum == 1:
            firstPageNum = 1
            lastPageNum = 10
            if lastPageNum > pageInfo.endPageNum:
                lastPageNum = pageInfo.endPageNum
        elif pageInfo.curPageNum == pageInfo.endPageNum:
            lastPageNum = pageInfo.endPageNum
            firstPageNum = pageInfo.curPageNum - 9
            if firstPageNum < 1:
                firstPageNum = 1
        pageInfo.page = firstPageNum
        pageInfo.pages = range(firstPageNum, lastPageNum + 1)
        pageInfo.firstPageNum = firstPageNum
        print(pageInfo.pages)
        return pageInfo        
    except Exception as e:
        errors.append(e)
        print(errors)
        return pageInfo
     
class DiffFeature():
    def __init__(self):
        self.num = None
        self.feature = []
def diffInfoShow(req):
    errors = []
    difftxt = None
    diffInfo = None
    try:
        if 'info' in req.GET:
            info = req.GET['info']
        diffInfo = INFO.objects.get(id=int(info))
        diffInfoList = []
        if diffInfo.diff_link:
            diffInfoList = INFO.objects.filter(diff_link=diffInfo.diff_link)
        with open(diffInfo.diff_file) as f:
            difftxt = f.read()
        # handle features
        diffFeatures = getDiffFeatures(diffInfo)
        return render_to_response('diffInfo.html', {'errors': errors, 'info':diffInfo, 'difftxt':difftxt, 'diffList':diffInfoList, 'diffFeatures':diffFeatures})
    except Exception as err:
        errors.append(err)
        return render_to_response('diffInfo.html', {'errors': errors})
    
def getDiffFeatures(info):
    str_sql = "select distinct number from vulnerability_difffeature where info_id_id=" + str(info.id)
    print(str_sql)
    rows = my_custom_sql(str_sql)
    print(rows)
    diffFeatures = []
    for row in rows:
        diffFeature = DiffFeature()
        diffFeature.num = row['number']
        print(diffFeature.num)
        diffFeature.feature = DIFFFEATURE.objects.filter(info_id=info, number=diffFeature.num)
        print(diffFeature.feature)
        diffFeatures.append(diffFeature)
    return diffFeatures

def my_custom_sql(str_sql):
    cursor = connection.cursor()
    cursor.execute(str_sql)
    desc = cursor.description
    rows = [ dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]
    return rows
def download(req):
    from django.http import StreamingHttpResponse
    errors = []
    try:
        def file_iterator(file_name, chunk_size=512):
            with open(file_name) as f:
                while True:
                    c = f.read(chunk_size)
                    if c:
                        yield c
                    else:
                        break
        if 'file' in req.GET:
            filename = req.GET['file']
            m = filename.split('\\')
            response = StreamingHttpResponse(file_iterator(filename))
            response['Content-Type'] = 'application/octet-stream'
            str1 = 'attachment;filename="diff_' + m[-1] + '"'
            response['Content-Disposition'] = str1.format(filename)
            return response
        
        if 'info'in req.GET:
            infoid = req.GET['info']
            func = req.GET['func']
            version = req.GET['version']
            info = INFO.objects.get(id=infoid)
            reuse = REUSE.objects.get(info_id=info, version=version, patch_func=func)
            response = StreamingHttpResponse(reuse.code)
            response['Content-Type'] = 'application/octet-stream'
            str1 = 'attachment;filename="' + info.cve.cve_id + '_' + reuse.patch_func + '.txt"'
            response['Content-Disposition'] = str1.format()
            return response
    except Exception as err:
        errors.append(err)
        return HttpResponse("Download failed!")  
def featureShow(req):
    errors = []
    try:
        features = FEATURE.objects.all()
        return render_to_response('aboutFeature.html', {'features':features})
    except Exception as err:
        errors.append(err)
        return render_to_response('aboutFeature.html', {'errors':errors})
